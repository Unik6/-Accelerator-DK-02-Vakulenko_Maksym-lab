-- -------------------------------------------------------------
-- 
-- File Name: hdlsrc\lab2\CALC_MAG_AND_PHASE_FIX_POIN.vhd
-- Created: 2023-01-11 03:13:15
-- 
-- Generated by MATLAB 9.12 and HDL Coder 3.20
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 1
-- Target subsystem base rate: 1
-- 
-- 
-- Clock Enable  Sample Time
-- -------------------------------------------------------------
-- ce_out        1
-- -------------------------------------------------------------
-- 
-- 
-- Output Signal                 Clock Enable  Sample Time
-- -------------------------------------------------------------
-- o_valid                       ce_out        1
-- o_magnitude                   ce_out        1
-- o_phase                       ce_out        1
-- -------------------------------------------------------------
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: CALC_MAG_AND_PHASE_FIX_POIN
-- Source Path: lab2/CALC_MAG_AND_PHASE_FIX_POIN
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.CALC_MAG_AND_PHASE_FIX_POIN_pkg.ALL;

ENTITY CALC_MAG_AND_PHASE_FIX_POIN IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        clk_enable                        :   IN    std_logic;
        in_valid                          :   IN    std_logic;
        i_complex_vallue_re               :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32_En16
        i_complex_vallue_im               :   IN    std_logic_vector(31 DOWNTO 0);  -- ufix32_En16
        ce_out                            :   OUT   std_logic;
        o_valid                           :   OUT   std_logic;
        o_magnitude                       :   OUT   std_logic_vector(32 DOWNTO 0);  -- ufix33_En16
        o_phase                           :   OUT   std_logic_vector(15 DOWNTO 0)  -- ufix16_En13
        );
END CALC_MAG_AND_PHASE_FIX_POIN;


ARCHITECTURE rtl OF CALC_MAG_AND_PHASE_FIX_POIN IS

  -- Component Declarations
  COMPONENT Sqrt
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          din                             :   IN    std_logic_vector(64 DOWNTO 0);  -- ufix65_En32
          dout                            :   OUT   std_logic_vector(32 DOWNTO 0)  -- ufix33_En16
          );
  END COMPONENT;

  COMPONENT atan2_cordic_nw
    PORT( clk                             :   IN    std_logic;
          reset                           :   IN    std_logic;
          enb                             :   IN    std_logic;
          y_in                            :   IN    std_logic_vector(32 DOWNTO 0);  -- sfix33_En16
          x_in                            :   IN    std_logic_vector(32 DOWNTO 0);  -- sfix33_En16
          angle                           :   OUT   std_logic_vector(32 DOWNTO 0)  -- sfix33_En30
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : Sqrt
    USE ENTITY work.Sqrt(rtl);

  FOR ALL : atan2_cordic_nw
    USE ENTITY work.atan2_cordic_nw(rtl);

  -- Signals
  SIGNAL enb                              : std_logic;
  SIGNAL delayMatch_reg                   : std_logic_vector(0 TO 34);  -- ufix1 [35]
  SIGNAL in_valid_1                       : std_logic;
  SIGNAL i_complex_vallue_re_unsigned     : unsigned(31 DOWNTO 0);  -- ufix32_En16
  SIGNAL i_complex_vallue_im_unsigned     : unsigned(31 DOWNTO 0);  -- ufix32_En16
  SIGNAL Product1_out1                    : unsigned(63 DOWNTO 0);  -- ufix64_En32
  SIGNAL Product_out1                     : unsigned(63 DOWNTO 0);  -- ufix64_En32
  SIGNAL Add1_add_cast                    : unsigned(64 DOWNTO 0);  -- ufix65_En32
  SIGNAL Add1_add_cast_1                  : unsigned(64 DOWNTO 0);  -- ufix65_En32
  SIGNAL Add1_out1                        : unsigned(64 DOWNTO 0);  -- ufix65_En32
  SIGNAL Sqrt_out1                        : std_logic_vector(32 DOWNTO 0);  -- ufix33
  SIGNAL ComplexValFixed1_out1            : signed(32 DOWNTO 0);  -- sfix33_En16
  SIGNAL ComplexValFixed2_out1            : signed(32 DOWNTO 0);  -- sfix33_En16
  SIGNAL Atan2_out1                       : std_logic_vector(32 DOWNTO 0);  -- ufix33
  SIGNAL Atan2_out1_signed                : signed(32 DOWNTO 0);  -- sfix33_En30
  SIGNAL ComplexValFixed_out1             : unsigned(15 DOWNTO 0);  -- ufix16_En13
  SIGNAL delayMatch1_reg                  : vector_of_unsigned16(0 TO 20);  -- ufix16 [21]
  SIGNAL ComplexValFixed_out1_1           : unsigned(15 DOWNTO 0);  -- ufix16_En13

BEGIN
  u_Sqrt : Sqrt
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              din => std_logic_vector(Add1_out1),  -- ufix65_En32
              dout => Sqrt_out1  -- ufix33_En16
              );

  u_Atan2_inst : atan2_cordic_nw
    PORT MAP( clk => clk,
              reset => reset,
              enb => clk_enable,
              y_in => std_logic_vector(ComplexValFixed1_out1),  -- sfix33_En16
              x_in => std_logic_vector(ComplexValFixed2_out1),  -- sfix33_En16
              angle => Atan2_out1  -- sfix33_En30
              );

  enb <= clk_enable;

  delayMatch_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayMatch_reg(0) <= in_valid;
        delayMatch_reg(1 TO 34) <= delayMatch_reg(0 TO 33);
      END IF;
    END IF;
  END PROCESS delayMatch_process;

  in_valid_1 <= delayMatch_reg(34);

  i_complex_vallue_re_unsigned <= unsigned(i_complex_vallue_re);

  Product1_out1 <= i_complex_vallue_re_unsigned * i_complex_vallue_re_unsigned;

  i_complex_vallue_im_unsigned <= unsigned(i_complex_vallue_im);

  Product_out1 <= i_complex_vallue_im_unsigned * i_complex_vallue_im_unsigned;

  Add1_add_cast <= resize(Product1_out1, 65);
  Add1_add_cast_1 <= resize(Product_out1, 65);
  Add1_out1 <= Add1_add_cast + Add1_add_cast_1;

  ComplexValFixed1_out1 <= signed(resize(i_complex_vallue_im_unsigned, 33));

  ComplexValFixed2_out1 <= signed(resize(i_complex_vallue_re_unsigned, 33));

  Atan2_out1_signed <= signed(Atan2_out1);

  ComplexValFixed_out1 <= unsigned(Atan2_out1_signed(32 DOWNTO 17)) + ('0' & (Atan2_out1_signed(16) AND (( NOT Atan2_out1_signed(32)) OR (Atan2_out1_signed(15) OR Atan2_out1_signed(14) OR Atan2_out1_signed(13) OR Atan2_out1_signed(12) OR Atan2_out1_signed(11) OR Atan2_out1_signed(10) OR Atan2_out1_signed(9) OR Atan2_out1_signed(8) OR Atan2_out1_signed(7) OR Atan2_out1_signed(6) OR Atan2_out1_signed(5) OR Atan2_out1_signed(4) OR Atan2_out1_signed(3) OR Atan2_out1_signed(2) OR Atan2_out1_signed(1) OR Atan2_out1_signed(0)))));

  delayMatch1_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      delayMatch1_reg <= (OTHERS => to_unsigned(16#0000#, 16));
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        delayMatch1_reg(0) <= ComplexValFixed_out1;
        delayMatch1_reg(1 TO 20) <= delayMatch1_reg(0 TO 19);
      END IF;
    END IF;
  END PROCESS delayMatch1_process;

  ComplexValFixed_out1_1 <= delayMatch1_reg(20);

  o_phase <= std_logic_vector(ComplexValFixed_out1_1);

  ce_out <= clk_enable;

  o_valid <= in_valid_1;

  o_magnitude <= Sqrt_out1;

END rtl;

